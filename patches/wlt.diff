--- inet.c~	2006-01-21 02:46:13.000000000 -0800
+++ inet.c	2007-01-03 15:54:13.000000000 -0800
@@ -144,7 +144,46 @@
 	 * on Solaris; we don't just omit loopback interfaces
 	 * becaue you *can* capture on loopback interfaces on some
 	 * OSes.
+	 *
+	 * On OS X, we don't do this check if the device
+	 * name begins with "wlt"; at least some versions
+	 * of OS X offer monitor mode capturing by having
+	 * a separate "monitor mode" device for each wireless
+	 * adapter, rather than by implementing the ioctls
+	 * that {Free,Net,Open,DragonFly}BSD provide.
+	 * Opening that device puts the adapter into monitor
+	 * mode, which, at least for some adapters, causes
+	 * them to deassociate from the network with which
+	 * they're associated.
+	 *
+	 * Instead, we try to open the corresponding "en"
+	 * device (so that we don't end up with, for users
+	 * without sufficient privilege to open capture
+	 * devices, a list of adapters that only includes
+	 * the wlt devices).
 	 */
+#ifdef __APPLE__
+	if (strncmp(name, "wlt", 3) == 0) {
+		char *en_name;
+		size_t en_name_len;
+
+		/*
+		 * Try to allocate a buffer for the "en"
+		 * device's name.
+		 */
+		en_name_len = strlen(name) - 1;
+		en_name = malloc(en_name_len + 1);
+		if (en_name == NULL) {
+			(void)snprintf(errbuf, PCAP_ERRBUF_SIZE,
+			    "malloc: %s", pcap_strerror(errno));
+			return (-1);
+		}
+		strcpy(en_name, "en");
+		strcat(en_name, name + 3);
+		p = pcap_open_live(en_name, 68, 0, 0, errbuf);
+		free(en_name);
+	} else
+#endif /* __APPLE */
 	p = pcap_open_live(name, 68, 0, 0, errbuf);
 	if (p == NULL) {
 		/*
